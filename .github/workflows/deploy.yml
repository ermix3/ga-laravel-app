name: Deploy Laravel Backend

on:
  push:
    branches:
      - main

env:
  REGISTRY: docker.io
  IMAGE_NAME: laravel-backend
  SHORT_SHA: ${{ github.sha }}
  DB_DATABASE: laravel
  DB_USERNAME: laravel
  NETWORK_NAME: fullstack-network

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Set short SHA
        run: echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Build and push
        uses: docker/build-push-action@v3
        with:
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ env.SHORT_SHA }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}

      - name: Check and install Docker on remote server
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_IP }} << EOF

            export NETWORK_NAME=${{ env.NETWORK_NAME }}

            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Docker not found. Installing Docker..."
              apt-get update
              apt-get install -y ca-certificates curl gnupg
              install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              chmod a+r /etc/apt/keyrings/docker.gpg
              echo "deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
              apt-get update
              apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              echo "Docker installed successfully."
            else
              echo "Docker is already installed."
            fi

            # Check if Docker Compose is installed
            if ! command -v docker compose &> /dev/null && ! command -v docker-compose &> /dev/null; then
              echo "Docker Compose not found. Installing Docker Compose..."
              apt-get update
              apt-get install -y docker-compose-plugin

              # If the plugin fails, try the standalone version as fallback
              if ! command -v docker compose &> /dev/null; then
                echo "Installing standalone Docker Compose as fallback..."
                curl -SL https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose
                chmod +x /usr/local/bin/docker-compose
              fi

              echo "Docker Compose installed successfully."
            else
              echo "Docker Compose is already installed."
            fi

            echo "Create backend directory if it doesn't exist"
            mkdir -p /backend

            # Ensuring Docker network exists...
            if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
              echo "Creating Docker network: $NETWORK_NAME"
              docker network create "$NETWORK_NAME"
            else
              echo "Network $NETWORK_NAME already exists."
            fi

            echo "Remove unused images to free disk space"
            docker image prune -af
          EOF

      - name: Copy docker compose and config to server
        run: |
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml root@${{ secrets.SERVER_IP }}:/backend/docker-compose.prod.yml

      - name: Create .env file on server
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_IP }} << 'EOF'
            cat > /backend/.env << 'EOT'
          APP_NAME=${{ secrets.APP_NAME }}
          APP_ENV=production
          APP_KEY=${{ secrets.APP_KEY }}
          APP_DEBUG=false
          APP_URL=http://${{ secrets.SERVER_IP }}

          APP_LOCALE=en
          APP_FALLBACK_LOCALE=en
          APP_FAKER_LOCALE=en_US

          APP_MAINTENANCE_DRIVER=file
          # APP_MAINTENANCE_STORE=database

          PHP_CLI_SERVER_WORKERS=4

          BCRYPT_ROUNDS=12

          LOG_CHANNEL=stack
          LOG_STACK=single
          LOG_DEPRECATIONS_CHANNEL=null
          LOG_LEVEL=debug

          DB_CONNECTION=mysql
          DB_HOST=db
          DB_PORT=3306
          DB_DATABASE=${{ env.DB_DATABASE }}
          DB_USERNAME=${{ env.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}

          SESSION_DRIVER=database
          SESSION_LIFETIME=120
          SESSION_ENCRYPT=false
          SESSION_PATH=/
          SESSION_DOMAIN=null

          BROADCAST_CONNECTION=log
          FILESYSTEM_DISK=local
          QUEUE_CONNECTION=sync

          CACHE_STORE=database
          # CACHE_PREFIX=

          MEMCACHED_HOST=127.0.0.1

          REDIS_CLIENT=phpredis
          REDIS_HOST=redis
          REDIS_PASSWORD=null
          REDIS_PORT=6379

          MAIL_MAILER=log
          MAIL_SCHEME=null
          MAIL_HOST=127.0.0.1
          MAIL_PORT=2525
          MAIL_USERNAME=null
          MAIL_PASSWORD=null
          MAIL_FROM_ADDRESS="hello@example.com"
          MAIL_FROM_NAME="${APP_NAME}"

          AWS_ACCESS_KEY_ID=
          AWS_SECRET_ACCESS_KEY=
          AWS_DEFAULT_REGION=us-east-1
          AWS_BUCKET=
          AWS_USE_PATH_STYLE_ENDPOINT=false

          VITE_APP_NAME="${APP_NAME}"
          EOT
          EOF

      - name: Deploy Backend via SSH
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_IP }} << EOF
            cd /backend

            export DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
            export IMAGE_NAME=${{ env.IMAGE_NAME }}
            export APP_NAME=${{ secrets.APP_NAME }}
            export APP_KEY=${{ secrets.APP_KEY }}
            export DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            export DB_DATABASE=${{ env.DB_DATABASE }}
            export DB_USERNAME=${{ env.DB_USERNAME }}
            export DB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}

            echo "Pull the latest image"
            docker pull ${{ env.REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest

            echo "Run with the appropriate docker compose command"
            if command -v docker compose &> /dev/null; then
              docker compose -f docker-compose.prod.yml down
              docker compose -f docker-compose.prod.yml up -d
            else
              docker-compose -f docker-compose.prod.yml down
              docker-compose -f docker-compose.prod.yml up -d
            fi

            echo "Run migrations after a short delay to ensure services are up"
            sleep 10
            if command -v docker compose &> /dev/null; then
              docker compose -f docker-compose.prod.yml exec -T backend php artisan migrate --force
            else
              docker-compose -f docker-compose.prod.yml exec -T backend php artisan migrate --force
            fi
          EOF
